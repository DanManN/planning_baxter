#!/usr/bin/env python

import sys
import copy
from math import pi, tau
from random import uniform, choice, shuffle
import time

import numpy as np

import rospy
from tf.transformations import *
# from geometry_msgs.msg import Twist
from gazebo_msgs.msg import ModelStates, ModelState
from moveit_commander.conversions import *

init_states_pub = None
updatePeriod = 0.5
lastUpdateTime = None
count = 0
count_2 = 0

ignore = {'ground_plane', 'table', 'baxter'}
directions = {
    'cylinder_red': [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'cylinder_blue': [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'stone_10_2_5_1cm_0': [0, choice([0, tau / 4]), choice(np.linspace(0, tau, 9)[:-1])],
    'round_tin_base': [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'wood_cube': [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'plastic_cup': [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'coke_can2' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'beer' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'green_prism' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'blue_prism' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'red_prism' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'purple_prism' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'teal_prism' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'yellow_prism' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'brown_cylinder' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'red_cylinder' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'blue_cylinder' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'green_cylinder' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'purple_cylinder' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'gray_cylinder' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'bleach_bottle' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'mustard_bottle' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'soup_can' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'meat_can' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'blue_can': [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'sugar_box' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'wood_block' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'red_mug' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    'cracker_box' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'drill' : [0, 0, choice(np.linspace(0, tau, 9)[:-1])],
    'apple' : [choice([0, tau / 4]), 0, choice(np.linspace(0, tau, 9)[:-1])],
    
}
#xyz coordinates
positions = [
		[9.5, -9.5, .03], [9.5, -8.5, .03], [9.5, -7.5, .03], [9.5, -6.5, .03], [9.5, -5.5, .03], 
		[.75, -.6, 1.05], [.75, -.3, 1.05], [.75, 0, 1.05], [.75, .3, 1.05], [.75, .6, 1.05]
]
shuffle(positions)

def on_model_states_msg(msg):
    global lastUpdateTime
    global count
    global count_2
    count_2 = 0
    sinceLastUpdateDuration = rospy.get_rostime() - lastUpdateTime
    if sinceLastUpdateDuration.to_sec() < updatePeriod:
        return
    lastUpdateTime = rospy.get_rostime()

    if count > 1:
        return
    else:
        count += 1

    for (model_name, model_pose) in zip(msg.name, msg.pose):
        if model_name not in ignore:
            #print(model_name)
            #print(model_pose)
            new_msg = ModelState()
            new_msg.model_name = model_name
            new_msg.reference_frame = "world"
            new_msg.pose = copy.deepcopy(model_pose)
            new_msg.pose.orientation
            # x = choice(np.linspace(tau, -tau, 9)[:-1])
            # y = choice(np.linspace(tau, -tau, 9)[:-1])
            # z = choice(np.linspace(tau, -tau, 9)[:-1])
            #print(directions[model_name])
            q = quaternion_from_euler(*directions[model_name])
            new_msg.pose.orientation.x = q[0]
            new_msg.pose.orientation.y = q[1]
            new_msg.pose.orientation.z = q[2]
            new_msg.pose.orientation.w = q[3]
            #new_msg.pose.position.z += 0.001
            #new_msg.pose.position.x = uniform(.55, .99)
            #new_msg.pose.position.x += choice([0,0.05, -0.05])
            #new_msg.pose.position.y += choice([0,0.05, -0.05])
            new_msg.pose.position.x = positions[count_2][0]
            new_msg.pose.position.y = positions[count_2][1]
            new_msg.pose.position.z = positions[count_2][2]
            #print(new_msg)
            if count == 1 and positions[count_2][2] > 1:
            	print(model_name, positions[count_2][0], positions[count_2][1], positions[count_2][2], q[0], q[1], q[2], q[3])
            count_2 += 1
            init_states_pub.publish(new_msg)
            
    	    
def printModelLocations():
    return

def main():
    rospy.init_node('gazebo_rand_instance')

    global init_states_pub
    init_states_pub = rospy.Publisher('/gazebo/set_model_state', ModelState, queue_size=10)
    # rospy.sleep(rospy.Duration(0, 100 * 1000))

    global lastUpdateTime
    lastUpdateTime = rospy.get_rostime()
    modelStatesSub = rospy.Subscriber('/gazebo/model_states', ModelStates, on_model_states_msg)
    #printModelLocations()
    
    # msg = rospy.wait_for_message('/gazebo/model_states', ModelStates)
    # rospy.sleep(rospy.Duration(0, 100 * 1000))

    # rospy.loginfo('Spinning')
    while count < 2:
        rospy.Rate(10).sleep()
    # rospy.spin()


if __name__ == '__main__':
    main()
